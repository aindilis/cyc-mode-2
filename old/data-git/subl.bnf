# BNF grammar for OpenCyc

ws : "\\s+" ;

subl_expression : "(" ws subl_function ws ")"
	;

subl_function : subl_intrinsic_function 
	| cyc_api_function
	;

subl_intrinsic_function : 
	;

cyc_api_function : cyc-tms-reconsider-sentence | cyc-rewrite | cyc-remove-argument | cyc-remove-all-arguments | cyc-add-argument | cyc-continue-query | cyc-query | cyc-edit | cyc-unassert | cyc-assert | cyc-merge | cyc-rename | cyc-recreate | cyc-kill | cyc-create-new-permanent | cyc-create-new-ephemeral | cyc-create | cyc-find-or-create | fi-get-warning | fi-get-error | fi-prove | fi-hypothesize | fi-tms-reconsider-term | fi-tms-reconsider-gafs | fi-tms-reconsider-mt | fi-tms-reconsider-formula | fi-ask-status | fi-continue-last-ask | fi-ask | fi-blast | fi-edit | fi-unassert | fi-assert | fi-lookup | fi-rename | fi-kill | fi-find-or-create | fi-create | fi-complete | fi-find | all-spec-attributes-if | all-spec-attributes | min-argn-genl-attribute | argn-genl-attribute-of | argn-genl-attribute | all-genl-attributes-wrt | all-genl-attributes-if | all-genl-attributes | gt-why-superior? | gt-why-completes-cycle? | gt-superiors | gt-roots | gt-redundant-superiors | gt-redundant-inferiors | gt-min-superiors-excluding | gt-min-superiors | gt-min-nodes | gt-min-ceilings | gt-max-nodes | gt-max-inferiors-excluding | gt-max-inferiors | gt-max-floors | gt-leaves | gt-inferiors | gt-has-superior? | gt-has-inferior? | gt-cycles? | gt-compose-fn-all-superiors | gt-compose-fn-all-inferiors | gt-completes-cycle? | gt-co-superiors | gt-co-inferiors | gt-any-superior-path | gt-all-superiors | gt-all-inferiors | gt-all-dependent-inferiors | gt-all-accessible | union-all-spec-predicates | union-all-spec-inverses | union-all-genl-predicates | union-all-genl-inverses | spec-predicates | spec-inverses | some-all-genl-inverses | not-spec-predicates | not-spec-inverses | not-genl-predicates | not-genl-inverses | genl-inverses | genl-predicates | all-genl-preds-among | some-all-spec-preds | map-all-spec-preds | some-all-genl-preds | map-all-genl-preds | max-floor-mts-of-genl-inverse-paths | max-floor-mts-of-genl-predicate-paths | max-floor-predicates | min-ceiling-predicates | max-predicates | min-predicates | why-not-genl-inverse? | why-genl-inverse? | why-not-genl-predicate? | why-genl-predicate? | intersecting-predicates? | any-not-genl-predicate? | not-genl-inverse? | not-genl-predicate? | any-genl-predicate? | spec-inverse? | genl-inverse? | genl-predicate? | spec-predicate? | all-not-spec-inverses | all-not-spec-predicates | all-spec-preds-wrt-arg | all-spec-preds-wrt-type | all-spec-inverses | all-spec-predicates | all-not-genl-inverses | all-not-genl-predicates | all-genl-inverses | all-genl-predicates | spec-inverse-siblings | spec-predicate-siblings | genl-inverse-siblings | genl-predicate-siblings | min-not-spec-inverses | min-not-spec-predicates | max-spec-inverses | max-spec-predicates | max-not-genl-inverses | max-not-genl-predicates | min-genl-inverses | min-genl-predicates | why-not-genl? | why-genl? | spec-siblings | all-specs-among | all-spec-any? | all-not-specs | all-not-spec? | all-genls-among | any-all-specs | map-all-specs | any-all-genls | map-all-genls | why-not-assert-genls? | max-floor-mts-of-genls-paths | shallower-col | lighter-col | any-genl-isa | why-collections-disjoint? | any-disjoint-collection-pair? | any-disjoint-collection-pair | max-floor-cols | min-ceiling-cols | max-cols | min-cols | collection-leaves | any-not-genl? | not-genl? | any-genl-all? | any-genl-any? | all-spec? | any-spec? | all-genl? | any-genl? | spec? | genl? | union-all-specs | all-dependent-specs | all-specs-if | all-specs | all-not-genls | all-genls-if | union-all-genls | all-genls-wrt | all-genls | spec-siblings | genl-siblings | min-not-specs | max-specs | max-not-genls | min-genls | union-all-instances | not-isa-among | min-not-instances | max-instances | instance-siblings | all-isas-wrt | all-isa-among | all-instances-among | why-not-isa? | why-isa? | max-floor-mts-of-isa-paths | isa-siblings | instances | instances? | not-isa? | any-isa-any? | isa-any? | isa? | map-instances | map-all-instances | any-wrt-all-isa | map-all-isa | all-instances | all-not-isa | union-all-isa | all-isa | max-not-isa | min-isa | diagnose-el-formula | el-query-ok? | el-formula-ok? | ground? | el-wff-syntax+arity? | el-wff-syntax? | assertion-el-formula | el-to-hl-query | el-to-hl | el-strength-p | count-all-instances | collections-intersect? | collections-disjoint? | collections-coextensional? | preds-for-pair | primitive-collection? | assertions-mentioning-terms | isa-relevant-assertions | all-term-assertions | reviewer | asserted-when | asserted-by | comment | creation-time | creator | result-isa | arity | all-sufficient-defns | sufficient-defns | necessary-defns | defining-defns | argn-genl-of | min-argn-genl | argn-genl | argn-isa-of | min-argn-isa | argn-isa | binary-predicate? | commutative-function? | commutative-relation? | relation? | transitive-predicate? | anti-symmetric-predicate? | asymmetric-predicate? | symmetric-predicate? | irreflexive-predicate? | reflexive-predicate? | pred-value-tuples-in-relevant-mts | pred-value-tuples-in-any-mt | pred-value-tuples-in-mts | pred-value-tuples-in-mt | pred-value-tuples | pred-u-v-holds-in-relevant-mts | pred-u-v-holds-in-any-mt | pred-u-v-holds-in-mts | pred-u-v-holds-in-mt | pred-u-v-holds | some-pred-value-in-relevant-mts | some-pred-value-in-any-mt | some-pred-value-in-mts | some-pred-value-in-mt | some-pred-value | pred-refs-in-relevant-mts | pred-refs-in-any-mt | pred-refs-in-mts | pred-refs-in-mt | pred-refs | pred-values-in-relevant-mts | pred-values-in-any-mt | pred-values-in-mts | pred-values-in-mt | pred-values | fpred-value-in-relevant-mts | fpred-value-in-any-mt | fpred-value-in-mts | fpred-value-in-mt | fpred-value | gather-term-assertions | gather-predicate-rule-index | gather-predicate-extent-index | gather-other-index | gather-nart-arg-index | gather-mt-index | gather-isa-rule-index | gather-genls-rule-index | gather-genl-mt-rule-index | gather-gaf-arg-index | gather-function-rule-index | gather-function-extent-index | gather-exception-rule-index | gather-index-in-any-mt | gather-index | map-other-index | map-mt-index | map-mt-contents | map-term-gafs | map-term-selective | map-term | relevant-num-predicate-extent-index | relevant-num-nart-arg-index | relevant-num-gaf-arg-index | relevant-num-function-extent-index | num-predicate-rule-index | num-predicate-extent-index | num-other-index | num-nart-arg-index | num-mt-index | num-isa-rule-index | num-index | num-genls-rule-index | num-genl-mt-rule-index | num-gaf-arg-index | num-function-rule-index | num-function-extent-index | num-exception-rule-index | key-predicate-rule-index | key-predicate-extent-index | key-nart-arg-index | key-isa-rule-index | key-genls-rule-index | key-genl-mt-rule-index | key-gaf-arg-index | key-function-rule-index | key-exception-rule-index | remove-term-indices | indexed-term-p | variable-count | fully-bound-p | default-el-var-for-hl-var | variable-id | find-variable-by-id | variable-p | el-var? | make-hl-support | hl-support-p | support-sentence | support-strength | support-truth | support-mt | support-module | support-p | deduction-count | deduction-assertion | find-deduction-by-id | deduction-id | deduction-p | argument-strength | argument-truth | argument-equal | asserted-argument-p | argument-p | hl-module-p | hl-term-p | atomic-clause-p | dnf-formula-from-clauses | dnf-formula | cnf-formula-from-clauses | cnf-formula | gaf-cnf? | cnf-p | ground-clause-p | clause-without-literal | clause-literal | empty-clause? | empty-clause | clause-equal | pos-lits | neg-lits | make-clause | sense-p | clause-p | negate | negated? | assertion-count | assertion-has-dependents-p | assertion-el-ist-formula | deduced-assertion? | asserted-assertion? | get-asserted-argument | find-all-gafs | find-gaf-any-mt | find-gaf | find-all-assertions | find-assertion-any-mt | find-assertion | find-assertion-by-id | assertion-has-meta-assertions? | assertion-strength | truth-p | assertion-has-truth | assertion-truth | code-assertion? | direction-p | backward-assertion? | forward-assertion? | assertion-direction | assertion-mt | assertion-mentions-term | assertion-ist-formula | assertion-formula | assertion-cnf | assertion-id | assertion-p | fort-count | remove-fort | fort-el-formula | el-fort-p | fort-p | nart-count | remove-nart | nart-el-formula | nart-hl-formula | find-nart-by-id | nart-id | nart-p | constant-apropos | constant-complete | constant-complete-exact | valid-constant-name | valid-constant-name-char | constant-count | remove-constant | uniquify-constant-name | rename-constant | find-or-create-constant | create-constant | find-constant-by-internal-id | find-constant-by-external-id | find-constant | constant-name | constant-internal-id | constant-external-id | constant-p
	;

cyc-tms-reconsider-sentence : "cyc-tms-reconsider-sentence" possibly-sentence-p &optional hlmt-p ;
cyc-rewrite : "cyc-rewrite" fort-p fort-p ;
cyc-remove-argument : "cyc-remove-argument" possibly-sentence-p list-of-cycl-support-p &optional hlmt-p ;
cyc-remove-all-arguments : "cyc-remove-all-arguments" possibly-sentence-p &optional hlmt-p ;
cyc-add-argument : "cyc-add-argument" possibly-sentence-p list-of-cycl-support-p &optional hlmt-p assert-properties-p booleanp ;
cyc-continue-query : "cyc-continue-query" &optional query-id-p query-properties-p ;
cyc-query : "cyc-query" possibly-sentence-p &optional hlmt-p query-properties-p ;
cyc-edit : "cyc-edit" possibly-sentence-p possibly-sentence-p &optional hlmt-p hlmt-p query-properties-p ;
cyc-unassert : "cyc-unassert" possibly-sentence-p &optional hlmt-p ;
cyc-assert : "cyc-assert" possibly-sentence-p &optional hlmt-p assert-properties-p ;
cyc-merge : "cyc-merge" fort-p fort-p ;
cyc-rename : "cyc-rename" constant-p valid-constant-name ;
cyc-recreate : "cyc-recreate" constant-p ;
cyc-kill : "cyc-kill" fort-p ;
cyc-create-new-permanent : "cyc-create-new-permanent" new-constant-name-spec-p ;
cyc-create-new-ephemeral : "cyc-create-new-ephemeral" new-constant-name-spec-p ;
cyc-create : "cyc-create" new-constant-name-spec-p constant-external-id-p ;
cyc-find-or-create : "cyc-find-or-create" valid-constant-name constant-external-id-p ;
fi-get-warning : "fi-get-warning"  ;
fi-get-error : "fi-get-error"  ;
fi-prove : "fi-prove" <formula> hlmt-p &optional <backchain> <number> <time> <depth> ;
fi-hypothesize : "fi-hypothesize" <formula> hlmt-p &optional <name-prefix> <term-ids> ;
fi-tms-reconsider-term : "fi-tms-reconsider-term" <term> &optional hlmt-p ;
fi-tms-reconsider-gafs : "fi-tms-reconsider-gafs" <term> &optional <arg> <predicate> hlmt-p ;
fi-tms-reconsider-mt : "fi-tms-reconsider-mt" hlmt-p ;
fi-tms-reconsider-formula : "fi-tms-reconsider-formula" <formula> hlmt-p ;
fi-ask-status : "fi-ask-status"  ;
fi-continue-last-ask : "fi-continue-last-ask" &optional <backchain> <number> <time> <depth> <reconsider-deep> ;
fi-ask : "fi-ask" <formula> &optional hlmt-p <backchain> <number> <time> <depth> ;
fi-blast : "fi-blast" <formula> hlmt-p ;
fi-edit : "fi-edit" <old-formula> <new-formula> &optional hlmt-p hlmt-p <strength> <direction> ;
fi-unassert : "fi-unassert" <formula> hlmt-p ;
fi-assert : "fi-assert" <formula> hlmt-p &optional <strength> <direction> ;
fi-lookup : "fi-lookup" <formula> hlmt-p ;
fi-rename : "fi-rename" constant-p valid-constant-name ;
fi-kill : "fi-kill" fort-p ;
fi-find-or-create : "fi-find-or-create" valid-constant-name &optional constant-external-id-p ;
fi-create : "fi-create" valid-constant-name &optional constant-external-id-p ;
fi-complete : "fi-complete" <prefix> &optional <case-sensitive?> ;
fi-find : "fi-find" valid-constant-name ;
all-spec-attributes-if : "all-spec-attributes-if" function-spec-p el-fort-p &optional hlmt-p <tv> ;
all-spec-attributes : "all-spec-attributes" el-fort-p &optional hlmt-p <tv> ;
min-argn-genl-attribute : "min-argn-genl-attribute" <relation> integerp &optional hlmt-p ;
argn-genl-attribute-of : "argn-genl-attribute-of" <collection> integerp &optional hlmt-p ;
argn-genl-attribute : "argn-genl-attribute" <relation> integerp &optional hlmt-p ;
all-genl-attributes-wrt : "all-genl-attributes-wrt" el-fort-p el-fort-p &optional hlmt-p <tv> ;
all-genl-attributes-if : "all-genl-attributes-if" function-spec-p el-fort-p &optional hlmt-p <tv> ;
all-genl-attributes : "all-genl-attributes" el-fort-p &optional hlmt-p <tv> ;
gt-why-superior? : "gt-why-superior?" fort-p fort-p fort-p &optional hlmt-p ;
gt-why-completes-cycle? : "gt-why-completes-cycle?" fort-p fort-p fort-p &optional hlmt-p ;
gt-superiors : "gt-superiors" fort-p fort-p &optional hlmt-p ;
gt-roots : "gt-roots" fort-p fort-p &optional hlmt-p ;
gt-redundant-superiors : "gt-redundant-superiors" fort-p fort-p &optional hlmt-p ;
gt-redundant-inferiors : "gt-redundant-inferiors" fort-p fort-p &optional hlmt-p ;
gt-min-superiors-excluding : "gt-min-superiors-excluding" fort-p fort-p fort-p &optional hlmt-p ;
gt-min-superiors : "gt-min-superiors" fort-p fort-p &optional hlmt-p ;
gt-min-nodes : "gt-min-nodes" fort-p listp &optional hlmt-p ;
gt-min-ceilings : "gt-min-ceilings" fort-p listp &optional <candidates> hlmt-p ;
gt-max-nodes : "gt-max-nodes" fort-p listp &optional hlmt-p <direction> ;
gt-max-inferiors-excluding : "gt-max-inferiors-excluding" fort-p fort-p fort-p &optional hlmt-p ;
gt-max-inferiors : "gt-max-inferiors" fort-p fort-p &optional hlmt-p ;
gt-max-floors : "gt-max-floors" fort-p listp &optional <candidates> hlmt-p ;
gt-leaves : "gt-leaves" fort-p fort-p &optional hlmt-p ;
gt-inferiors : "gt-inferiors" fort-p fort-p &optional hlmt-p ;
gt-has-superior? : "gt-has-superior?" fort-p fort-p fort-p &optional hlmt-p ;
gt-has-inferior? : "gt-has-inferior?" fort-p fort-p fort-p &optional hlmt-p ;
gt-cycles? : "gt-cycles?" fort-p fort-p &optional hlmt-p ;
gt-compose-fn-all-superiors : "gt-compose-fn-all-superiors" fort-p fort-p function-spec-p &optional <combine-fn> hlmt-p ;
gt-compose-fn-all-inferiors : "gt-compose-fn-all-inferiors" fort-p fort-p function-spec-p &optional <combine-fn> hlmt-p ;
gt-completes-cycle? : "gt-completes-cycle?" fort-p fort-p fort-p &optional hlmt-p ;
gt-co-superiors : "gt-co-superiors" fort-p fort-p &optional hlmt-p ;
gt-co-inferiors : "gt-co-inferiors" fort-p fort-p &optional hlmt-p ;
gt-any-superior-path : "gt-any-superior-path" fort-p fort-p fort-p &optional hlmt-p ;
gt-all-superiors : "gt-all-superiors" fort-p fort-p &optional hlmt-p ;
gt-all-inferiors : "gt-all-inferiors" fort-p fort-p &optional hlmt-p ;
gt-all-dependent-inferiors : "gt-all-dependent-inferiors" fort-p fort-p &optional hlmt-p ;
gt-all-accessible : "gt-all-accessible" fort-p fort-p &optional hlmt-p ;
union-all-spec-predicates : "union-all-spec-predicates" listp &optional hlmt-p <tv> ;
union-all-spec-inverses : "union-all-spec-inverses" listp &optional hlmt-p <tv> ;
union-all-genl-predicates : "union-all-genl-predicates" listp &optional hlmt-p <tv> ;
union-all-genl-inverses : "union-all-genl-inverses" listp &optional hlmt-p <tv> ;
spec-predicates : "spec-predicates" fort-p &optional hlmt-p <tv> ;
spec-inverses : "spec-inverses" fort-p &optional hlmt-p <tv> ;
some-all-genl-inverses : "some-all-genl-inverses" fort-p function-spec-p &optional hlmt-p <tv> ;
not-spec-predicates : "not-spec-predicates" fort-p &optional hlmt-p <tv> ;
not-spec-inverses : "not-spec-inverses" fort-p &optional hlmt-p <tv> ;
not-genl-predicates : "not-genl-predicates" fort-p &optional hlmt-p <tv> ;
not-genl-inverses : "not-genl-inverses" fort-p &optional hlmt-p <tv> ;
genl-inverses : "genl-inverses" fort-p &optional hlmt-p <tv> ;
genl-predicates : "genl-predicates" fort-p &optional hlmt-p <tv> ;
all-genl-preds-among : "all-genl-preds-among" el-fort-p listp &optional hlmt-p <tv> ;
some-all-spec-preds : "some-all-spec-preds" fort-p function-spec-p &optional hlmt-p <tv> ;
map-all-spec-preds : "map-all-spec-preds" fort-p function-spec-p &optional hlmt-p <tv> ;
some-all-genl-preds : "some-all-genl-preds" fort-p function-spec-p &optional hlmt-p <tv> ;
map-all-genl-preds : "map-all-genl-preds" fort-p function-spec-p &optional hlmt-p <tv> ;
max-floor-mts-of-genl-inverse-paths : "max-floor-mts-of-genl-inverse-paths" fort-p fort-p &optional <tv> ;
max-floor-mts-of-genl-predicate-paths : "max-floor-mts-of-genl-predicate-paths" fort-p fort-p &optional <tv> ;
max-floor-predicates : "max-floor-predicates" listp &optional listp hlmt-p <tv> ;
min-ceiling-predicates : "min-ceiling-predicates" listp &optional listp hlmt-p <tv> ;
max-predicates : "max-predicates" listp &optional hlmt-p <tv> ;
min-predicates : "min-predicates" listp &optional hlmt-p <tv> ;
why-not-genl-inverse? : "why-not-genl-inverse?" fort-p fort-p &optional hlmt-p <tv> <behavior> ;
why-genl-inverse? : "why-genl-inverse?" fort-p fort-p &optional hlmt-p <tv> <behavior> ;
why-not-genl-predicate? : "why-not-genl-predicate?" fort-p fort-p &optional hlmt-p <tv> <behavior> ;
why-genl-predicate? : "why-genl-predicate?" fort-p fort-p &optional hlmt-p <tv> <behavior> ;
intersecting-predicates? : "intersecting-predicates?" fort-p fort-p &optional hlmt-p ;
any-not-genl-predicate? : "any-not-genl-predicate?" fort-p listp &optional hlmt-p <tv> ;
not-genl-inverse? : "not-genl-inverse?" fort-p fort-p &optional hlmt-p <tv> ;
not-genl-predicate? : "not-genl-predicate?" fort-p fort-p &optional hlmt-p <tv> ;
any-genl-predicate? : "any-genl-predicate?" fort-p listp &optional hlmt-p <tv> ;
spec-inverse? : "spec-inverse?" fort-p fort-p &optional hlmt-p <tv> ;
genl-inverse? : "genl-inverse?" fort-p fort-p &optional hlmt-p <tv> ;
genl-predicate? : "genl-predicate?" fort-p fort-p &optional hlmt-p <tv> ;
spec-predicate? : "spec-predicate?" fort-p fort-p &optional hlmt-p <tv> ;
all-not-spec-inverses : "all-not-spec-inverses" fort-p &optional hlmt-p <tv> ;
all-not-spec-predicates : "all-not-spec-predicates" fort-p &optional hlmt-p <tv> ;
all-spec-preds-wrt-arg : "all-spec-preds-wrt-arg" fort-p fort-p integerp &optional hlmt-p <tv> ;
all-spec-preds-wrt-type : "all-spec-preds-wrt-type" fort-p fort-p integerp &optional hlmt-p <tv> ;
all-spec-inverses : "all-spec-inverses" fort-p &optional hlmt-p <tv> ;
all-spec-predicates : "all-spec-predicates" fort-p &optional hlmt-p <tv> ;
all-not-genl-inverses : "all-not-genl-inverses" fort-p &optional hlmt-p <tv> ;
all-not-genl-predicates : "all-not-genl-predicates" fort-p &optional hlmt-p <tv> ;
all-genl-inverses : "all-genl-inverses" fort-p &optional hlmt-p <tv> ;
all-genl-predicates : "all-genl-predicates" fort-p &optional hlmt-p <tv> ;
spec-inverse-siblings : "spec-inverse-siblings" fort-p &optional hlmt-p <tv> ;
spec-predicate-siblings : "spec-predicate-siblings" fort-p &optional hlmt-p <tv> ;
genl-inverse-siblings : "genl-inverse-siblings" fort-p &optional hlmt-p <tv> ;
genl-predicate-siblings : "genl-predicate-siblings" fort-p &optional hlmt-p <tv> ;
min-not-spec-inverses : "min-not-spec-inverses" fort-p &optional hlmt-p <tv> ;
min-not-spec-predicates : "min-not-spec-predicates" fort-p &optional hlmt-p <tv> ;
max-spec-inverses : "max-spec-inverses" fort-p &optional hlmt-p <tv> ;
max-spec-predicates : "max-spec-predicates" fort-p &optional hlmt-p <tv> ;
max-not-genl-inverses : "max-not-genl-inverses" fort-p &optional hlmt-p <tv> ;
max-not-genl-predicates : "max-not-genl-predicates" fort-p &optional hlmt-p <tv> ;
min-genl-inverses : "min-genl-inverses" fort-p &optional hlmt-p <tv> ;
min-genl-predicates : "min-genl-predicates" fort-p &optional hlmt-p <tv> ;
why-not-genl? : "why-not-genl?" el-fort-p el-fort-p &optional hlmt-p <tv> <behavior> ;
why-genl? : "why-genl?" el-fort-p el-fort-p &optional hlmt-p <tv> <behavior> ;
spec-siblings : "spec-siblings" el-fort-p &optional hlmt-p <tv> ;
all-specs-among : "all-specs-among" el-fort-p listp &optional hlmt-p <tv> ;
all-spec-any? : "all-spec-any?" listp listp &optional hlmt-p <tv> ;
all-not-specs : "all-not-specs" el-fort-p &optional hlmt-p <tv> ;
all-not-spec? : "all-not-spec?" el-fort-p listp &optional hlmt-p <tv> ;
all-genls-among : "all-genls-among" el-fort-p listp &optional hlmt-p <tv> ;
any-all-specs : "any-all-specs" function-spec-p el-fort-p &optional hlmt-p <tv> ;
map-all-specs : "map-all-specs" function-spec-p el-fort-p &optional hlmt-p <tv> ;
any-all-genls : "any-all-genls" function-spec-p el-fort-p &optional hlmt-p <tv> ;
map-all-genls : "map-all-genls" function-spec-p el-fort-p &optional hlmt-p <tv> ;
why-not-assert-genls? : "why-not-assert-genls?" el-fort-p el-fort-p &optional hlmt-p ;
max-floor-mts-of-genls-paths : "max-floor-mts-of-genls-paths" el-fort-p el-fort-p &optional <tv> ;
shallower-col : "shallower-col" el-fort-p el-fort-p ;
lighter-col : "lighter-col" el-fort-p el-fort-p ;
any-genl-isa : "any-genl-isa" el-fort-p el-fort-p &optional hlmt-p <tv> ;
why-collections-disjoint? : "why-collections-disjoint?" el-fort-p el-fort-p &optional hlmt-p ;
any-disjoint-collection-pair? : "any-disjoint-collection-pair?" listp &optional hlmt-p ;
any-disjoint-collection-pair : "any-disjoint-collection-pair" listp &optional hlmt-p ;
max-floor-cols : "max-floor-cols" listp &optional listp hlmt-p <tv> ;
min-ceiling-cols : "min-ceiling-cols" listp &optional listp hlmt-p <tv> ;
max-cols : "max-cols" listp &optional hlmt-p <tv> ;
min-cols : "min-cols" listp &optional hlmt-p <tv> ;
collection-leaves : "collection-leaves" el-fort-p &optional hlmt-p <tv> ;
any-not-genl? : "any-not-genl?" el-fort-p listp &optional hlmt-p <tv> ;
not-genl? : "not-genl?" el-fort-p el-fort-p &optional hlmt-p <tv> ;
any-genl-all? : "any-genl-all?" listp listp &optional hlmt-p <tv> ;
any-genl-any? : "any-genl-any?" listp listp &optional hlmt-p <tv> ;
all-spec? : "all-spec?" el-fort-p listp &optional hlmt-p <tv> ;
any-spec? : "any-spec?" el-fort-p listp &optional hlmt-p <tv> ;
all-genl? : "all-genl?" el-fort-p listp &optional hlmt-p <tv> ;
any-genl? : "any-genl?" el-fort-p listp &optional hlmt-p <tv> ;
spec? : "spec?" el-fort-p el-fort-p &optional hlmt-p <tv> ;
genl? : "genl?" el-fort-p el-fort-p &optional hlmt-p <tv> ;
union-all-specs : "union-all-specs" listp &optional hlmt-p <tv> ;
all-dependent-specs : "all-dependent-specs" el-fort-p &optional hlmt-p <tv> ;
all-specs-if : "all-specs-if" function-spec-p el-fort-p &optional hlmt-p <tv> ;
all-specs : "all-specs" el-fort-p &optional hlmt-p <tv> ;
all-not-genls : "all-not-genls" el-fort-p &optional hlmt-p <tv> ;
all-genls-if : "all-genls-if" function-spec-p el-fort-p &optional hlmt-p <tv> ;
union-all-genls : "union-all-genls" listp &optional hlmt-p <tv> ;
all-genls-wrt : "all-genls-wrt" el-fort-p el-fort-p &optional hlmt-p <tv> ;
all-genls : "all-genls" el-fort-p &optional hlmt-p <tv> ;
spec-siblings : "spec-siblings" el-fort-p &optional hlmt-p <tv> ;
genl-siblings : "genl-siblings" el-fort-p &optional hlmt-p <tv> ;
min-not-specs : "min-not-specs" el-fort-p &optional hlmt-p <tv> ;
max-specs : "max-specs" el-fort-p &optional hlmt-p <tv> ;
max-not-genls : "max-not-genls" el-fort-p &optional hlmt-p <tv> ;
min-genls : "min-genls" el-fort-p &optional hlmt-p <tv> ;
union-all-instances : "union-all-instances" listp &optional hlmt-p <tv> ;
not-isa-among : "not-isa-among" hl-term-p listp &optional hlmt-p <tv> ;
min-not-instances : "min-not-instances" el-fort-p &optional hlmt-p <tv> ;
max-instances : "max-instances" el-fort-p &optional hlmt-p <tv> ;
instance-siblings : "instance-siblings" el-fort-p &optional hlmt-p <tv> ;
all-isas-wrt : "all-isas-wrt" el-fort-p el-fort-p &optional hlmt-p <tv> ;
all-isa-among : "all-isa-among" hl-term-p listp &optional hlmt-p <tv> ;
all-instances-among : "all-instances-among" hl-term-p listp &optional hlmt-p <tv> ;
why-not-isa? : "why-not-isa?" hl-term-p el-fort-p &optional hlmt-p <tv> <behavior> ;
why-isa? : "why-isa?" hl-term-p el-fort-p &optional hlmt-p <tv> <behavior> ;
max-floor-mts-of-isa-paths : "max-floor-mts-of-isa-paths" hl-term-p el-fort-p &optional <tv> ;
isa-siblings : "isa-siblings" hl-term-p &optional hlmt-p <tv> ;
instances : "instances" el-fort-p &optional hlmt-p <tv> ;
instances? : "instances?" el-fort-p &optional hlmt-p <tv> ;
not-isa? : "not-isa?" hl-term-p el-fort-p &optional hlmt-p <tv> ;
any-isa-any? : "any-isa-any?" listp listp &optional hlmt-p <tv> ;
isa-any? : "isa-any?" hl-term-p listp &optional hlmt-p <tv> ;
isa? : "isa?" hl-term-p el-fort-p &optional hlmt-p <tv> ;
map-instances : "map-instances" function-spec-p el-fort-p &optional hlmt-p <tv> ;
map-all-instances : "map-all-instances" function-spec-p el-fort-p &optional hlmt-p <tv> ;
any-wrt-all-isa : "any-wrt-all-isa" function-spec-p hl-term-p &optional hlmt-p <tv> ;
map-all-isa : "map-all-isa" function-spec-p hl-term-p &optional hlmt-p <tv> ;
all-instances : "all-instances" el-fort-p &optional hlmt-p <tv> ;
all-not-isa : "all-not-isa" hl-term-p &optional hlmt-p <tv> ;
union-all-isa : "union-all-isa" listp &optional hlmt-p <tv> ;
all-isa : "all-isa" hl-term-p &optional hlmt-p <tv> ;
max-not-isa : "max-not-isa" hl-term-p &optional hlmt-p <tv> ;
min-isa : "min-isa" hl-term-p &optional hlmt-p <tv> ;
diagnose-el-formula : "diagnose-el-formula" listp &optional hlmt-p <io-mode> ;
el-query-ok? : "el-query-ok?" listp &optional hlmt-p ;
el-formula-ok? : "el-formula-ok?" listp &optional hlmt-p ;
ground? : "ground?" <expression> &optional <var?> ;
el-wff-syntax+arity? : "el-wff-syntax+arity?" listp &optional hlmt-p ;
el-wff-syntax? : "el-wff-syntax?" listp &optional hlmt-p ;
assertion-el-formula : "assertion-el-formula" assertion-p ;
el-to-hl-query : "el-to-hl-query" el-formula-p &optional hlmt-p ;
el-to-hl : "el-to-hl" el-formula-p &optional hlmt-p ;
el-strength-p : "el-strength-p" <object> ;
count-all-instances : "count-all-instances" el-fort-p &optional hlmt-p <tv> ;
collections-intersect? : "collections-intersect?" el-fort-p el-fort-p &optional hlmt-p ;
collections-disjoint? : "collections-disjoint?" el-fort-p el-fort-p &optional hlmt-p ;
collections-coextensional? : "collections-coextensional?" el-fort-p el-fort-p &optional hlmt-p ;
preds-for-pair : "preds-for-pair" fort-p fort-p &optional hlmt-p <mode> ;
primitive-collection? : "primitive-collection?" fort-p &optional hlmt-p ;
assertions-mentioning-terms : "assertions-mentioning-terms" <term-list> &optional <include-meta-assertions?> ;
isa-relevant-assertions : "isa-relevant-assertions" hl-term-p &optional hlmt-p ;
all-term-assertions : "all-term-assertions" indexed-term-p &optional <remove-duplicates?> ;
reviewer : "reviewer" fort-p &optional hlmt-p ;
asserted-when : "asserted-when" assertion-p ;
asserted-by : "asserted-by" assertion-p ;
comment : "comment" fort-p &optional hlmt-p ;
creation-time : "creation-time" fort-p &optional hlmt-p ;
creator : "creator" fort-p &optional hlmt-p ;
result-isa : "result-isa" <functor> &optional hlmt-p ;
arity : "arity" <relation> &optional hlmt-p ;
all-sufficient-defns : "all-sufficient-defns" el-fort-p &optional hlmt-p ;
sufficient-defns : "sufficient-defns" el-fort-p &optional hlmt-p ;
necessary-defns : "necessary-defns" el-fort-p &optional hlmt-p ;
defining-defns : "defining-defns" el-fort-p &optional hlmt-p ;
argn-genl-of : "argn-genl-of" el-fort-p integerp &optional hlmt-p ;
min-argn-genl : "min-argn-genl" <relation> integerp &optional hlmt-p ;
argn-genl : "argn-genl" <relation> integerp &optional hlmt-p ;
argn-isa-of : "argn-isa-of" el-fort-p integerp &optional hlmt-p ;
min-argn-isa : "min-argn-isa" indexed-term-p integerp &optional hlmt-p ;
argn-isa : "argn-isa" indexed-term-p integerp &optional hlmt-p ;
binary-predicate? : "binary-predicate?" fort-p &optional hlmt-p ;
commutative-function? : "commutative-function?" function-spec-p &optional hlmt-p ;
commutative-relation? : "commutative-relation?" indexed-term-p &optional hlmt-p ;
relation? : "relation?" indexed-term-p &optional hlmt-p ;
transitive-predicate? : "transitive-predicate?" fort-p &optional hlmt-p ;
anti-symmetric-predicate? : "anti-symmetric-predicate?" fort-p &optional hlmt-p ;
asymmetric-predicate? : "asymmetric-predicate?" fort-p &optional hlmt-p ;
symmetric-predicate? : "symmetric-predicate?" fort-p &optional hlmt-p ;
irreflexive-predicate? : "irreflexive-predicate?" fort-p &optional hlmt-p ;
reflexive-predicate? : "reflexive-predicate?" fort-p &optional hlmt-p ;
pred-value-tuples-in-relevant-mts : "pred-value-tuples-in-relevant-mts" indexed-term-p fort-p integerp listp &optional hlmt-p truth-p ;
pred-value-tuples-in-any-mt : "pred-value-tuples-in-any-mt" indexed-term-p fort-p integerp listp &optional truth-p ;
pred-value-tuples-in-mts : "pred-value-tuples-in-mts" indexed-term-p fort-p integerp listp listp &optional truth-p ;
pred-value-tuples-in-mt : "pred-value-tuples-in-mt" indexed-term-p fort-p integerp listp hlmt-p &optional truth-p ;
pred-value-tuples : "pred-value-tuples" indexed-term-p fort-p integerp listp &optional truth-p ;
pred-u-v-holds-in-relevant-mts : "pred-u-v-holds-in-relevant-mts" fort-p indexed-term-p hl-term-p &optional hlmt-p integerp integerp truth-p ;
pred-u-v-holds-in-any-mt : "pred-u-v-holds-in-any-mt" fort-p indexed-term-p hl-term-p &optional integerp integerp truth-p ;
pred-u-v-holds-in-mts : "pred-u-v-holds-in-mts" fort-p indexed-term-p hl-term-p listp &optional integerp integerp truth-p ;
pred-u-v-holds-in-mt : "pred-u-v-holds-in-mt" fort-p indexed-term-p hl-term-p hlmt-p &optional integerp integerp truth-p ;
pred-u-v-holds : "pred-u-v-holds" fort-p indexed-term-p hl-term-p &optional integerp integerp truth-p ;
some-pred-value-in-relevant-mts : "some-pred-value-in-relevant-mts" indexed-term-p fort-p &optional hlmt-p integerp truth-p ;
some-pred-value-in-any-mt : "some-pred-value-in-any-mt" indexed-term-p fort-p &optional integerp truth-p ;
some-pred-value-in-mts : "some-pred-value-in-mts" indexed-term-p fort-p listp &optional integerp truth-p ;
some-pred-value-in-mt : "some-pred-value-in-mt" indexed-term-p fort-p hlmt-p &optional integerp truth-p ;
some-pred-value : "some-pred-value" indexed-term-p fort-p &optional integerp truth-p ;
pred-refs-in-relevant-mts : "pred-refs-in-relevant-mts" fort-p &optional hlmt-p integerp truth-p ;
pred-refs-in-any-mt : "pred-refs-in-any-mt" fort-p &optional integerp truth-p ;
pred-refs-in-mts : "pred-refs-in-mts" fort-p listp &optional integerp truth-p ;
pred-refs-in-mt : "pred-refs-in-mt" fort-p hlmt-p &optional integerp truth-p ;
pred-refs : "pred-refs" fort-p &optional integerp truth-p ;
pred-values-in-relevant-mts : "pred-values-in-relevant-mts" indexed-term-p fort-p &optional hlmt-p integerp integerp truth-p ;
pred-values-in-any-mt : "pred-values-in-any-mt" indexed-term-p fort-p &optional integerp integerp truth-p ;
pred-values-in-mts : "pred-values-in-mts" indexed-term-p fort-p listp &optional integerp integerp truth-p ;
pred-values-in-mt : "pred-values-in-mt" indexed-term-p fort-p hlmt-p &optional integerp integerp truth-p ;
pred-values : "pred-values" indexed-term-p fort-p &optional integerp integerp truth-p ;
fpred-value-in-relevant-mts : "fpred-value-in-relevant-mts" indexed-term-p fort-p &optional hlmt-p integerp integerp truth-p ;
fpred-value-in-any-mt : "fpred-value-in-any-mt" indexed-term-p fort-p &optional integerp integerp truth-p ;
fpred-value-in-mts : "fpred-value-in-mts" indexed-term-p fort-p listp &optional integerp integerp truth-p ;
fpred-value-in-mt : "fpred-value-in-mt" indexed-term-p fort-p hlmt-p &optional integerp integerp truth-p ;
fpred-value : "fpred-value" indexed-term-p fort-p &optional integerp integerp truth-p ;
gather-term-assertions : "gather-term-assertions" indexed-term-p &optional hlmt-p ;
gather-predicate-rule-index : "gather-predicate-rule-index" fort-p sense-p &optional hlmt-p <direction> ;
gather-predicate-extent-index : "gather-predicate-extent-index" fort-p &optional hlmt-p truth-p ;
gather-other-index : "gather-other-index" indexed-term-p ;
gather-nart-arg-index : "gather-nart-arg-index" indexed-term-p positive-integer-p &optional <func> ;
gather-mt-index : "gather-mt-index" indexed-term-p ;
gather-isa-rule-index : "gather-isa-rule-index" el-fort-p sense-p &optional hlmt-p <direction> ;
gather-genls-rule-index : "gather-genls-rule-index" el-fort-p sense-p &optional hlmt-p <direction> ;
gather-genl-mt-rule-index : "gather-genl-mt-rule-index" <genl-mt> sense-p &optional <rule-mt> <direction> ;
gather-gaf-arg-index : "gather-gaf-arg-index" indexed-term-p positive-integer-p &optional fort-p hlmt-p truth-p ;
gather-function-rule-index : "gather-function-rule-index" <func> &optional hlmt-p <direction> ;
gather-function-extent-index : "gather-function-extent-index" <func> ;
gather-exception-rule-index : "gather-exception-rule-index" <rule> &optional hlmt-p <direction> ;
gather-index-in-any-mt : "gather-index-in-any-mt" indexed-term-p &optional <remove-duplicates?> ;
gather-index : "gather-index" indexed-term-p &optional <remove-duplicates?> ;
map-other-index : "map-other-index" function-spec-p indexed-term-p &optional truth-p <gafs-only> ;
map-mt-index : "map-mt-index" function-spec-p hlmt-p &optional truth-p <gafs-only> ;
map-mt-contents : "map-mt-contents" function-spec-p indexed-term-p &optional truth-p <gafs-only> ;
map-term-gafs : "map-term-gafs" function-spec-p indexed-term-p &optional truth-p ;
map-term-selective : "map-term-selective" function-spec-p indexed-term-p function-spec-p &optional truth-p ;
map-term : "map-term" function-spec-p indexed-term-p ;
relevant-num-predicate-extent-index : "relevant-num-predicate-extent-index" fort-p ;
relevant-num-nart-arg-index : "relevant-num-nart-arg-index" indexed-term-p &optional positive-integer-p <func> ;
relevant-num-gaf-arg-index : "relevant-num-gaf-arg-index" indexed-term-p &optional positive-integer-p fort-p ;
relevant-num-function-extent-index : "relevant-num-function-extent-index" <func> ;
num-predicate-rule-index : "num-predicate-rule-index" fort-p &optional sense-p hlmt-p <direction> ;
num-predicate-extent-index : "num-predicate-extent-index" fort-p &optional hlmt-p ;
num-other-index : "num-other-index" indexed-term-p ;
num-nart-arg-index : "num-nart-arg-index" indexed-term-p &optional positive-integer-p <func> ;
num-mt-index : "num-mt-index" indexed-term-p ;
num-isa-rule-index : "num-isa-rule-index" el-fort-p &optional sense-p hlmt-p <direction> ;
num-index : "num-index" indexed-term-p ;
num-genls-rule-index : "num-genls-rule-index" el-fort-p &optional sense-p hlmt-p <direction> ;
num-genl-mt-rule-index : "num-genl-mt-rule-index" el-fort-p &optional sense-p hlmt-p <direction> ;
num-gaf-arg-index : "num-gaf-arg-index" indexed-term-p &optional positive-integer-p fort-p hlmt-p ;
num-function-rule-index : "num-function-rule-index" <func> &optional hlmt-p <direction> ;
num-function-extent-index : "num-function-extent-index" <func> ;
num-exception-rule-index : "num-exception-rule-index" <rule> &optional hlmt-p <direction> ;
key-predicate-rule-index : "key-predicate-rule-index" fort-p &optional sense-p hlmt-p ;
key-predicate-extent-index : "key-predicate-extent-index" fort-p ;
key-nart-arg-index : "key-nart-arg-index" indexed-term-p &optional positive-integer-p <func> ;
key-isa-rule-index : "key-isa-rule-index" el-fort-p &optional sense-p hlmt-p ;
key-genls-rule-index : "key-genls-rule-index" el-fort-p &optional sense-p hlmt-p ;
key-genl-mt-rule-index : "key-genl-mt-rule-index" el-fort-p &optional sense-p hlmt-p ;
key-gaf-arg-index : "key-gaf-arg-index" indexed-term-p &optional positive-integer-p fort-p ;
key-function-rule-index : "key-function-rule-index" <func> &optional hlmt-p ;
key-exception-rule-index : "key-exception-rule-index" <rule> &optional hlmt-p ;
remove-term-indices : "remove-term-indices" indexed-term-p ;
indexed-term-p : "indexed-term-p" <object> ;
variable-count : "variable-count"  ;
fully-bound-p : "fully-bound-p" <object> ;
default-el-var-for-hl-var : "default-el-var-for-hl-var" variable-p ;
variable-id : "variable-id" variable-p ;
find-variable-by-id : "find-variable-by-id" integerp ;
variable-p : "variable-p" <object> ;
el-var? : "el-var?" <object> ;
make-hl-support : "make-hl-support" hl-module-p possibly-sentence-p &optional fort-p tv-p ;
hl-support-p : "hl-support-p" <object> ;
support-sentence : "support-sentence" support-p ;
support-strength : "support-strength" support-p ;
support-truth : "support-truth" support-p ;
support-mt : "support-mt" support-p ;
support-module : "support-module" support-p ;
support-p : "support-p" <object> ;
deduction-count : "deduction-count"  ;
deduction-assertion : "deduction-assertion" deduction-p ;
find-deduction-by-id : "find-deduction-by-id" integerp ;
deduction-id : "deduction-id" deduction-p ;
deduction-p : "deduction-p" <object> ;
argument-strength : "argument-strength" argument-p ;
argument-truth : "argument-truth" argument-p ;
argument-equal : "argument-equal" <argument1> <argument2> ;
asserted-argument-p : "asserted-argument-p" <object> ;
argument-p : "argument-p" <object> ;
hl-module-p : "hl-module-p" <object> ;
hl-term-p : "hl-term-p" <obj> ;
atomic-clause-p : "atomic-clause-p" <clause> ;
dnf-formula-from-clauses : "dnf-formula-from-clauses" listp ;
dnf-formula : "dnf-formula" <dnf> ;
cnf-formula-from-clauses : "cnf-formula-from-clauses" listp ;
cnf-formula : "cnf-formula" cnf-p &optional truth-p ;
gaf-cnf? : "gaf-cnf?" cnf-p ;
cnf-p : "cnf-p" <object> ;
ground-clause-p : "ground-clause-p" <clause> ;
clause-without-literal : "clause-without-literal" clause-p sense-p integerp ;
clause-literal : "clause-literal" clause-p sense-p integerp ;
empty-clause? : "empty-clause?" clause-p ;
empty-clause : "empty-clause"  ;
clause-equal : "clause-equal" <clause1> <clause2> ;
pos-lits : "pos-lits" clause-p ;
neg-lits : "neg-lits" clause-p ;
make-clause : "make-clause" listp listp ;
sense-p : "sense-p" <object> ;
clause-p : "clause-p" <object> ;
negate : "negate" el-formula-p ;
negated? : "negated?" el-formula-p ;
assertion-count : "assertion-count"  ;
assertion-has-dependents-p : "assertion-has-dependents-p" assertion-p ;
assertion-el-ist-formula : "assertion-el-ist-formula" assertion-p ;
deduced-assertion? : "deduced-assertion?" assertion-p ;
asserted-assertion? : "asserted-assertion?" assertion-p ;
get-asserted-argument : "get-asserted-argument" assertion-p ;
find-all-gafs : "find-all-gafs" el-formula-p ;
find-gaf-any-mt : "find-gaf-any-mt" el-formula-p ;
find-gaf : "find-gaf" el-formula-p fort-p ;
find-all-assertions : "find-all-assertions" cnf-p ;
find-assertion-any-mt : "find-assertion-any-mt" cnf-p ;
find-assertion : "find-assertion" cnf-p fort-p ;
find-assertion-by-id : "find-assertion-by-id" integerp ;
assertion-has-meta-assertions? : "assertion-has-meta-assertions?" assertion-p ;
assertion-strength : "assertion-strength" assertion-p ;
truth-p : "truth-p" <object> ;
assertion-has-truth : "assertion-has-truth" assertion-p truth-p ;
assertion-truth : "assertion-truth" assertion-p ;
code-assertion? : "code-assertion?" assertion-p ;
direction-p : "direction-p" <object> ;
backward-assertion? : "backward-assertion?" assertion-p ;
forward-assertion? : "forward-assertion?" assertion-p ;
assertion-direction : "assertion-direction" assertion-p ;
assertion-mt : "assertion-mt" assertion-p ;
assertion-mentions-term : "assertion-mentions-term" assertion-p hl-term-p ;
assertion-ist-formula : "assertion-ist-formula" assertion-p ;
assertion-formula : "assertion-formula" assertion-p ;
assertion-cnf : "assertion-cnf" assertion-p ;
assertion-id : "assertion-id" assertion-p ;
assertion-p : "assertion-p" <object> ;
fort-count : "fort-count"  ;
remove-fort : "remove-fort" fort-p ;
fort-el-formula : "fort-el-formula" fort-p ;
el-fort-p : "el-fort-p" <object> ;
fort-p : "fort-p" <object> ;
nart-count : "nart-count"  ;
remove-nart : "remove-nart" nart-p ;
nart-el-formula : "nart-el-formula" nart-p ;
nart-hl-formula : "nart-hl-formula" nart-p ;
find-nart-by-id : "find-nart-by-id" integerp ;
nart-id : "nart-id" nart-p ;
nart-p : "nart-p" <object> ;
constant-apropos : "constant-apropos" stringp &optional booleanp fixnump <end> ;
constant-complete : "constant-complete" stringp &optional booleanp booleanp fixnump <end> ;
constant-complete-exact : "constant-complete-exact" stringp &optional fixnump <end> ;
valid-constant-name : "valid-constant-name" stringp ;
valid-constant-name-char : "valid-constant-name-char" characterp ;
constant-count : "constant-count"  ;
remove-constant : "remove-constant" constant-p ;
uniquify-constant-name : "uniquify-constant-name" stringp ;
rename-constant : "rename-constant" constant-p stringp ;
find-or-create-constant : "find-or-create-constant" stringp &optional constant-external-id-p ;
create-constant : "create-constant" stringp &optional constant-external-id-p ;
find-constant-by-internal-id : "find-constant-by-internal-id" constant-internal-id-p ;
find-constant-by-external-id : "find-constant-by-external-id" constant-external-id-p ;
find-constant : "find-constant" stringp ;
constant-name : "constant-name" constant-p ;
constant-internal-id : "constant-internal-id" constant-p ;
constant-external-id : "constant-external-id" constant-p ;
constant-p : "constant-p" <object> ;

<arg> : "" ;
<argument1> : "" ;
<argument2> : "" ;
<backchain> : "" ;
<behavior> : "" ;
<candidates> : "" ;
<case-sensitive?> : "" ;
<clause1> : "" ;
<clause2> : "" ;
<clause> : "" ;
<collection> : "" ;
<combine-fn> : "" ;
<depth> : "" ;
<direction> : "" ;
<dnf> : "" ;
<end> : "" ;
<expression> : "" ;
<formula> : "" ;
<func> : "" ;
<functor> : "" ;
<gafs-only> : "" ;
<genl-mt> : "" ;
<include-meta-assertions?> : "" ;
<io-mode> : "" ;
<mode> : "" ;
<name-prefix> : "" ;
<new-formula> : "" ;
<number> : "" ;
<obj> : "" ;
<object> : "" ;
<old-formula> : "" ;
<predicate> : "" ;
<prefix> : "" ;
<reconsider-deep> : "" ;
<relation> : "" ;
<remove-duplicates?> : "" ;
<rule-mt> : "" ;
<rule> : "" ;
<strength> : "" ;
<term-ids> : "" ;
<term-list> : "" ;
<term> : "" ;
<time> : "" ;
<tv> : "" ;
<var?> : "" ;
argument-p : "" ;
assert-properties-p : "" ;
assertion-p : "" ;
booleanp : "" ;
characterp : "" ;
clause-p : "" ;
cnf-p : "" ;
constant-external-id-p : "" ;
constant-internal-id-p : "" ;
constant-p : "" ;
deduction-p : "" ;
el-formula-p : "" ;
el-fort-p : "" ;
fixnump : "" ;
fort-p : "" ;
function-spec-p : "" ;
hl-module-p : "" ;
hl-term-p : "" ;
hlmt-p : "" ;
indexed-term-p : "" ;
integerp : "" ;
list-of-cycl-support-p : "" ;
listp : "" ;
nart-p : "" ;
new-constant-name-spec-p : "" ;
positive-integer-p : "" ;
possibly-sentence-p : "" ;
query-id-p : "" ;
query-properties-p : "" ;
sense-p : "" ;
stringp : "" ;
support-p : "" ;
truth-p : "" ;
tv-p : "" ;
valid-constant-name : "" ;
variable-p : "" ;
